单例：保证一个类只有一个实例，并提供一个访问该实例的全局访问点
    场景： 任务管理器，回收站 ，应用程序的日志文件，数据库的连接池
            在Spring中，每个Bean默认也是单例的
            SpringMVC 中控制器也是
    种类: 懒汉：程安全 ，调用效率高，但是不能延时加载
          饿汉：线程synchronized 用安全 ，调用效率低，可以能延时加载
         双重检测锁 ：由于JVM底层内部模型原因，偶尔会出现问题，不建议使用
         静态内部类：线程安全 调用效率高 ，并且实现了延时加载。但是肯能会有反射和反序列化的造成问题
         枚举单例 ：天然实现线程安全和单一实例 ，不能延时加载
    如何选用：
    单例对象 占用 资源少 不需要 延时加载
    枚举 好于 饿汉
    单例对象 占用 资源多 需要 延时加载
    静态内部类 好于 懒汉式

工厂:核心 实现了创建者和调用者的分离(分工明确)
场景： JDK中Calendar的getInstance方法
      JDBC中的Connection对象
      Spring中IOC容器创建管理bean
      ------
面向对象设计的基本原则：
OCP:开闭原则  对扩展开放：对已有的修改关闭
DIP:依赖倒转原则 ：依赖于抽象，不能具体实现间相互依赖
LOD:迪米特法则：和你直接的朋友通信，避免和陌生人通信（类和类之间尽量少的发生关系）
1. 简单工厂模式：（同一个产品）
 优点：简单：易用，静态
 缺点：不能增加新的类，无法扩展。不能满足OCP原则
2 工厂方法模式：（同一个产品）
优点：满足OCP原则，消费者和创造者分开
缺点：代码复杂，增加了消费者的难度
3 抽象工厂模式：（不同的产品族;但是对于一个产品族中增加产品也是无能为力）
注意：工厂模式可以套用其他模式

建造者模式：
建造者模式中零件的建造者(Bulider)，和零件的装配者(Director)。对于二建造者和装配者都属属于生成者；
所以消费者可以消费 不同的建造者和不同的装配者的不同组合
由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以是不同的对象；
相同的构造器，不同的装配顺序也可以做成不同的对象。也就实现了构建算法，装配算法的解耦
实现更好的复用

原型模式（PROTOTYPE）:也叫克隆模式
通过Cloneable接口和Clone方法
Prototype模式实现最困难的地方是内存的复制操作，所幸Java中提供了clone()方法替我们做这些事情；深层来说：
clone()方法其实是一个native方法也就是他调用的是本地的C语言程序来实现的，所以是高效的。
1 理解一个问题：深拷贝和浅拷贝
        深拷贝 是不仅仅是拷贝对象，并且会将对象中需要的属性对象也拷贝一份。一起拷贝。原对象的属性改变，拷贝对象的属性不改变
        浅拷贝  仅仅是拷贝对象的引用。


